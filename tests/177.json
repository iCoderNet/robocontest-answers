{"code":"#define _USE_MATH_DEFINES\r\n#include <cassert>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <iostream>\r\n#include <string>\r\n#include <sstream>\r\n#include <vector>\r\n#include <queue>\r\n#include <list>\r\n#include <set>\r\n#include <map>\r\n#include <unordered_set>\r\n#include <unordered_map>\r\n#include <algorithm>\r\n#include <complex>\r\n#include <cmath>\r\n#include <numeric>\r\n#include <bitset>\r\n\r\nusing namespace std;\r\n\r\ntypedef long long int64;\r\ntypedef pair<int64, int64> ii;\r\nconst int64 INF = 1LL << 60;\r\n\r\nconst int N = 2e5 + 10;\r\nstruct Node {\r\n  int a, b;\r\n  Node *left, *right;\r\n  Node* fa;\r\n};\r\n\r\nNode pool[N], *last;\r\nvector<ii> a[N];\r\n\r\nNode* build(int aa, int bb, Node* fa) {\r\n  Node* cur = last++;\r\n  cur->a = aa;\r\n  cur->b = bb;\r\n  cur->fa = fa;\r\n  if (aa + 1 == bb) return cur;\r\n  cur->left = build(aa, (aa + bb) \/ 2, cur);\r\n  cur->right = build((aa + bb) \/ 2, bb, cur);\r\n  return cur;\r\n}\r\n\r\nint A, B;\r\nvector<int> C;\r\n\r\nvoid traverse(Node* cur) {\r\n  if (cur->a >= A && cur->b <= B){\r\n    C.push_back(cur - pool);\r\n    return;\r\n  }\r\n  if ((cur->a + cur->b) \/ 2 > A) traverse(cur->left);\r\n  if ((cur->a + cur->b) \/ 2 < B) traverse(cur->right);\r\n}\r\n\r\nint64 d[N << 1];\r\nint pre[N];\r\n\r\nvoid dijkstra(int s, int n) {\r\n  fill(d, d + n * 2, INF);\r\n  priority_queue<ii, vector<ii>, greater<ii> > Q;\r\n  d[s] = 0;\r\n  Q.push({0, s});\r\n  while (!Q.empty()) {\r\n    ii top = Q.top();\r\n    Q.pop();\r\n    int v = top.second;\r\n    int64 dd = top.first;\r\n    if (dd > d[v]) continue;\r\n    Node* p = v < n ? pool + v : pool + v - n;\r\n    if (v < n) {\r\n      for (auto& it : a[v]) {\r\n        int u = it.first;\r\n        int64 cost = it.second;\r\n        if (d[u] > d[v] + cost) {\r\n          d[u] = d[v] + cost;\r\n          pre[u] = v;\r\n          Q.push({d[u], u});\r\n        }\r\n      }\r\n      if (p->b - p->a > 1) {\r\n        int u = p->left - pool;\r\n        if (d[u] > d[v]) {\r\n          d[u] = d[v];\r\n          pre[u] = v;\r\n          Q.push({d[u], u});\r\n        }\r\n        u = p->right - pool;\r\n        if (d[u] > d[v]) {\r\n          d[u] = d[v];\r\n          pre[u] = v;\r\n          Q.push({d[u], u});\r\n        }\r\n      }\r\n    } else {\r\n      for (auto& it : a[v - n]) {\r\n        int u = it.first;\r\n        int64 cost = it.second;\r\n        if (d[u] > d[v] + cost) {\r\n          d[u] = d[v] + cost;\r\n          pre[u] = v;\r\n          Q.push({d[u], u});\r\n        }\r\n      }\r\n    }\r\n    if (p->fa) {\r\n      int u = p->fa - pool + n;\r\n      if (d[u] > d[v]) {\r\n        d[u] = d[v];\r\n        Q.push({d[u], u});\r\n      }\r\n    }\r\n\r\n  }\r\n}\r\nint main() {\r\n  int n, m, s;\r\n  scanf(\"%d%d%d\", &n, &m, &s);\r\n  last = pool;\r\n  Node* root = build(0, n, nullptr);\r\n  while (m--) {\r\n    int t, u, v, L, R, z;\r\n    int x, y;\r\n    scanf(\"%d\", &t);\r\n    if (t == 1) {\r\n      scanf(\"%d%d%d\", &u, &v, &z);\r\n      --u; --v;\r\n      A = u; B = u + 1; C.clear();\r\n      traverse(root);\r\n      x = C[0];\r\n      A = v; B = v + 1; C.clear();\r\n      traverse(root);\r\n      y = C[0];\r\n      a[x].push_back({y, z});\r\n    } else if (t == 2) {\r\n      scanf(\"%d%d%d%d\", &u, &L, &R, &z);\r\n      --u; --L;\r\n      A = u; B = u + 1; C.clear();\r\n      traverse(root);\r\n      x = C[0];\r\n      A = L; B = R; C.clear();\r\n      traverse(root);\r\n      for (auto& y : C) {\r\n        a[x].push_back({y, z});\r\n      }\r\n    } else {\r\n      scanf(\"%d%d%d%d\", &u, &L, &R, &z);\r\n      --u; --L;\r\n      A = u; B = u + 1; C.clear();\r\n      traverse(root);\r\n      y = C[0];\r\n      A = L; B = R; C.clear();\r\n      traverse(root);\r\n      for (auto& x : C) {\r\n        a[x].push_back({y, z});\r\n      }\r\n    }\r\n  }\r\n  --s;\r\n  A = s; B = s + 1; C.clear();\r\n  traverse(root);\r\n  s = C[0];\r\n  dijkstra(s, last - pool);\r\n  for (int i = 0; i < n; ++i) {\r\n    A = i; B = i + 1; C.clear();\r\n    traverse(root);\r\n    int x = C[0];\r\n    printf(\"%lld%c\", d[x] == INF ? -1 : d[x], \" \\n\"[i + 1 == n]);\r\n  }\r\n  return 0;\r\n}","lang":4}