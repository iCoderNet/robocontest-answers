{"code":"#include <bits\/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nclass DSU\r\n{\r\n\tint *parent;\r\n\tint *rank;\r\n\r\npublic:\r\n\tDSU(int n)\r\n\t{\r\n\t\tparent = new int[n];\r\n\t\trank = new int[n];\r\n\r\n\t\tfor (int i = 0; i < n; i++)\r\n\t\t{\r\n\t\t\tparent[i] = -1;\r\n\t\t\trank[i] = 1;\r\n\t\t}\r\n\t}\r\n\r\n\tint find(int i)\r\n\t{\r\n\t\tif (parent[i] == -1)\r\n\t\t\treturn i;\r\n\r\n\t\treturn parent[i] = find(parent[i]);\r\n\t}\r\n\tvoid unite(int x, int y)\r\n\t{\r\n\t\tint s1 = find(x);\r\n\t\tint s2 = find(y);\r\n\r\n\t\tif (s1 != s2)\r\n\t\t{\r\n\t\t\tif (rank[s1] < rank[s2])\r\n\t\t\t{\r\n\t\t\t\tparent[s1] = s2;\r\n\t\t\t\trank[s2] += rank[s1];\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tparent[s2] = s1;\r\n\t\t\t\trank[s1] += rank[s2];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\nclass Graph\r\n{\r\n\tvector<vector<int>> edgelist;\r\n\tint V;\r\n\r\npublic:\r\n\tGraph(int V)\r\n\t{\r\n\t\tthis->V = V;\r\n\t}\r\n\r\n\tvoid addEdge(int x, int y, int w)\r\n\t{\r\n\t\tedgelist.push_back({w, x, y});\r\n\t}\r\n\r\n\tint kruskals_mst()\r\n\t{\r\n\t\tsort(edgelist.begin(), edgelist.end());\r\n\r\n\t\tDSU s(V);\r\n\t\tint ans = 0;\r\n\t\tfor (auto edge : edgelist)\r\n\t\t{\r\n\t\t\tint w = edge[0];\r\n\t\t\tint x = edge[1];\r\n\t\t\tint y = edge[2];\r\n\r\n\t\t\tif (s.find(x) != s.find(y))\r\n\t\t\t{\r\n\t\t\t\ts.unite(x, y);\r\n\t\t\t\tans += w;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ans;\r\n\t}\r\n};\r\nint32_t main()\r\n{\r\n    int n, m, xx;\r\n    scanf(\"%lld%lld%lld\",&n,&m,&xx);\r\n \r\n    Graph g(n);\r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        int x, y, w;\r\n        scanf(\"%lld%lld%lld\",&x,&y,&w);\r\n        g.addEdge(x - 1, y - 1, w);\r\n    }\r\n\tint kk = g.kruskals_mst() * xx;\r\n\tcout << kk;\r\n\treturn 0;\r\n}","lang":4}