{"code":"\/*\r\n\u2588\u2588    \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588   \u2588\u2588\r\n\u2588\u2588\u2588  \u2588\u2588\u2588  \u2588\u2588        \u2588\u2588     \u2588\u2588 \u2588\u2588\r\n\u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588        \u2588\u2588      \u2588\u2588\r\n\u2588\u2588    \u2588\u2588  \u2588\u2588        \u2588\u2588      \u2588\u2588\r\n\r\n  \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588     \u2588\u2588      \u2588\u2588   \u2588\u2588  \u2588\u2588  \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588   \u2588\u2588\r\n \u2588\u2588        \u2588\u2588       \u2588\u2588\u2588\u2588     \u2588\u2588   \u2588\u2588  \u2588\u2588 \u2588\u2588   \u2588\u2588      \u2588\u2588   \u2588\u2588\r\n \u2588\u2588        \u2588\u2588      \u2588\u2588  \u2588\u2588    \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588    \u2588\u2588\u2588\u2588    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\r\n \u2588\u2588        \u2588\u2588     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588   \u2588\u2588  \u2588\u2588 \u2588\u2588   \u2588\u2588      \u2588\u2588   \u2588\u2588\r\n  \u2588\u2588\u2588\u2588     \u2588\u2588    \u2588\u2588\u2588    \u2588\u2588\u2588  \u2588\u2588   \u2588\u2588  \u2588\u2588  \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588   \u2588\u2588\r\n*\/\r\n#include <bits\/stdc++.h>\r\nusing namespace std;\r\n \r\nconst int N = 200010;\r\nconst int S = 1 << 18;\r\nint bb[N];\r\n \r\nint n, q, a[N];\r\n \r\nstruct node {\r\n  long long sum, pref;\r\n  node(long long sum, long long pref) : sum(sum), pref(pref) {}\r\n  node(long long x = 0) : sum(x), pref(max(0LL, x)) {}\r\n  friend node operator+(const node& a, const node& b) {\r\n    return {a.sum + b.sum, max(a.pref, a.sum + b.pref)};\r\n  }\r\n} tt[S << 1];\r\n \r\nvoid build(int k = 1, int l = 1, int r = n) {\r\n  if (l == r) { tt[k] = node(a[l]); return; }\r\n  int m = (l + r) >> 1;\r\n  build(k << 1, l, m);\r\n  build(k << 1 | 1, m + 1, r);\r\n  tt[k] = tt[k << 1] + tt[k << 1 | 1];\r\n}\r\n \r\nvoid update(int i, int x, int k = 1, int l = 1, int r = n) {\r\n  if (l == r) { tt[k] = node(x); return; }\r\n  int m = (l + r) >> 1;\r\n  if (i <= m) update(i, x, k << 1, l, m);\r\n  else update(i, x, k << 1 | 1, m + 1, r);\r\n  tt[k] = tt[k << 1] + tt[k << 1 | 1];\r\n}\r\n \r\nnode query(int ql, int qr, int k = 1, int l = 1, int r = n) {\r\n  if (ql > r || qr < l) return 0;\r\n  if (ql <= l && qr >= r) return tt[k];\r\n  int m = (l + r) >> 1;\r\n  node q1 = query(ql, qr, k << 1, l, m);\r\n  node q2 = query(ql, qr, k << 1 | 1, m + 1, r);\r\n  return q1 + q2;\r\n}\r\n \r\nint main() {\r\n  scanf(\"%d%d\", &n, &q);\r\n  for (int i = 1; i <= n; ++i)\r\n    scanf(\"%d\", a + i);\r\n  build();\r\n  for (int i = 0, t, x, y; i < q; ++i) {\r\n    scanf(\"%d%d%d\", &t, &x, &y);\r\n    if (t == 1) update(x, a[x] = y);\r\n    else printf(\"%lld\\n\", query(x, y).pref);\r\n  }\r\n}","lang":4}