{"code":"#pragma GCC optimize(\"Ofast\")\r\n\r\n#pragma GCC optimize (\"unroll-loops\")\r\n\r\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\r\n\r\n\r\n\r\n\r\n\r\n#include <bits\/stdc++.h>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\nnamespace io{\r\n\r\n\r\n\r\n    template<typename First, typename Second> ostream& operator << ( ostream &os, const pair<First, Second> &p ) { return os << p.first << \" \" << p.second; }\r\n\r\n    template<typename First, typename Second> ostream& operator << ( ostream &os, const map<First, Second> &mp ) { for( auto it : mp ) { os << it << endl;  } return os; }\r\n\r\n    template<typename First> ostream& operator << ( ostream &os, const vector<First> &v ) { bool space = false; for( First x : v ) { if( space ) os << \" \"; space = true; os << x; } return os; }\r\n\r\n    template<typename First> ostream& operator << ( ostream &os, const set<First> &st ) { bool space = false; for( First x : st ) { if( space ) os << \" \"; space = true; os << x; } return os; }\r\n\r\n    template<typename First> ostream& operator << ( ostream &os, const multiset<First> &st ) { bool space = false; for( First x : st ) { if( space ) os << \" \"; space = true; os << x; } return os; }\r\n\r\n\r\n\r\n    template<typename First, typename Second> istream& operator >> ( istream &is, pair<First, Second> &p ) { return is >> p.first >> p.second; }\r\n\r\n    template<typename First> istream& operator >> ( istream &is, vector<First> &v ) { for( First &x : v ) { is >> x; } return is; }\r\n\r\n    \r\n\r\n    long long fastread(){ char c; long long d = 1, x = 0; do c = getchar(); while( c == ' ' || c == '\\n' ); if( c == '-' ) c = getchar(), d = -1; while( isdigit( c ) ){ x = x * 10 + c - '0'; c = getchar(); } return d * x; }\r\n\r\n    \r\n\r\n    static bool sep = false;\r\n\r\n\r\n\r\n    using std::to_string;\r\n\r\n\r\n\r\n    string to_string( bool x ){ return ( x ? \"true\" : \"false\" ); }\r\n\r\n    string to_string( const string & s ){ return \"\\\"\" + s + \"\\\"\"; }\r\n\r\n    string to_string( const char * s ){ return \"\\\"\" + string( s ) + \"\\\"\"; }\r\n\r\n    string to_string ( const char & c ) { string s; s += c; return \"\\'\" + s + \"\\'\"; }\r\n\r\n\r\n\r\n    template<typename Type> string to_string( vector<Type> );\r\n\r\n    template<typename First, typename Second> string to_string( pair<First, Second> );\r\n\r\n    template<typename Collection> string to_string( Collection );\r\n\r\n\r\n\r\n    template<typename First, typename Second> string to_string( pair<First, Second> p ){ return \"{\" + to_string( p.first ) + \", \" + to_string( p.second ) + \"}\"; }\r\n\r\n    template<typename Type> string to_string( vector<Type> v ) { bool sep = false; string s = \"[\"; for( Type x: v ){ if( sep ) s += \", \"; sep = true; s += to_string( x ); } s += \"]\"; return s; }\r\n\r\n    template<typename Collection> string to_string( Collection collection ) { bool sep = false; string s = \"{\"; for( auto x: collection ){ if( sep ) s += \", \"; sep = true; s += to_string( x ); } s += \"}\"; return s; }\r\n\r\n\r\n\r\n    void print() { cerr << endl; sep = false; }\r\n\r\n    template <typename First, typename... Other> void print( First first, Other... other ) { if( sep ) cerr << \" | \"; sep = true; cerr << to_string( first ); print( other... ); }\r\n\r\n\r\n\r\n} using namespace io;\r\n\r\n\r\n\r\nnamespace utils {\r\n\r\n\r\n\r\n    class Range {\r\n\r\n        private:\r\n\r\n            const int start;\r\n\r\n            const int stop;\r\n\r\n            const int step;\r\n\r\n            \r\n\r\n        public:\r\n\r\n            class iterator {\r\n\r\n            private:\r\n\r\n                int value;\r\n\r\n                const int step;\r\n\r\n                const int boundary;\r\n\r\n                const bool sign;\r\n\r\n\r\n\r\n            public:\r\n\r\n                typedef std::forward_iterator_tag iterator_category;\r\n\r\n                typedef int &reference;\r\n\r\n                typedef int *pointer;\r\n\r\n\r\n\r\n                iterator( int value, int step, int boundary ) : value( value ), step( step ), boundary( boundary ), sign( step > 0 ) {}\r\n\r\n                iterator operator ++ () { value += step; return *this; }\r\n\r\n                reference operator * () { return value; }\r\n\r\n                const pointer operator -> () { return &value; }\r\n\r\n                bool operator == ( const iterator& rhs ) { return sign ? ( value >= rhs.value && value > boundary ) : (value <= rhs.value && value < boundary ); }\r\n\r\n                bool operator != ( const iterator& rhs ) { return sign ? ( value < rhs.value && value >= boundary ) : ( value > rhs.value && value <= boundary ); }\r\n\r\n            };\r\n\r\n\r\n\r\n            Range( const int &start, const int &stop, const int &step ) : start( start ), stop( stop ), step( step ) {}      \r\n\r\n            iterator begin() const { return iterator( start, step, start ); }\r\n\r\n            iterator end() const { return iterator( stop, step, start ); }\r\n\r\n    };\r\n\r\n\r\n\r\n    Range range( const int &stop ) { return Range( 0, stop, 1 ); }\r\n\r\n    Range range( const int &start, const int &stop ) { return Range( start, stop, 1 ); }\r\n\r\n    Range range( const int &start, const int &stop, const int &step ) { return Range( start, stop, step ); }\r\n\r\n\r\n\r\n    template<typename T> inline T max( T t ) { return t; }\r\n\r\n    template<typename First, typename ...Others> inline auto max( First first, Others ...others ) { auto result = max( others... ); return result > first ? result : first; }\r\n\r\n    \r\n\r\n    template<typename T> inline T min( T t ) { return t; }\r\n\r\n    template<typename First, typename ...Others> inline auto min( First first, Others ...others ) { auto result = min( others... ); return result < first ? result : first; }\r\n\r\n\r\n\r\n    template<typename T1, typename T2> inline void updmax ( T1 &a, T2 b ) { a = a > b ? a : b; }\r\n\r\n    template<typename T1, typename T2> inline void updmin ( T1 &a, T2 b ) { a = a < b ? a : b; }\r\n\r\n\r\n\r\n    template<typename T1, typename T2> inline bool chkmax ( T1 &a, T2 b ) { if( a < b ) { a = b; return true; } return false; }\r\n\r\n    template<typename T1, typename T2> inline bool chkmin ( T1 &a, T2 b ) { if( a > b ) { a = b; return true; } return false; }\r\n\r\n \r\n\r\n    constexpr long long operator\"\" _E ( unsigned long long n ){ long long p = 1, a = 10; for( int i = 0; i < n; i++ ) p *= a; return p; }\r\n\r\n    long double operator\"\" _deg ( long double deg ){ long double PI = acos( -1 ); return deg * PI \/ 180; }\r\n\r\n\r\n\r\n    random_device rd; mt19937 mt( rd( ) );\r\n\r\n    template<typename T> T rand ( T l, T r ) { uniform_int_distribution<T> dist( l, r ); return dist( mt ); }; \r\n\r\n\r\n\r\n    namespace Color {\r\n\r\n        string \r\n\r\n        HEADER = \"\\033[95m\",\r\n\r\n        OKBLUE = \"\\033[94m\",\r\n\r\n        OKGREEN = \"\\033[92m\",\r\n\r\n        WARNING = \"\\033[93m\",\r\n\r\n        FAIL = \"\\033[91m\",\r\n\r\n        ENDC = \"\\033[0m\",\r\n\r\n        BOLD = \"\\033[1m\",\r\n\r\n        UNDERLINE = \"\\033[4m\",\r\n\r\n        BGGREEN = \"\\x1b[6;30;42m\";\r\n\r\n    }\r\n\r\n\r\n\r\n    struct dtime {\r\n\r\n        int h, m, s;\r\n\r\n        \r\n\r\n        dtime( int h, int m, int s ) : h( h ), m( m ), s( s ) {}\r\n\r\n    \r\n\r\n        dtime() { \r\n\r\n            h = ( ( time( 0 ) \/ 60 \/ 60 ) % 24 + 5 ) % 24;\r\n\r\n            m  = ( time( 0 ) \/ 60 ) % 60;\r\n\r\n            s = time( 0 ) % 60;\r\n\r\n        }\r\n\r\n\r\n\r\n        friend bool operator < ( const dtime &t1, const dtime &t2 ){\r\n\r\n            if( t1.h == t2.h ){\r\n\r\n                if( t1.m == t2.m ){\r\n\r\n                    return t1.s < t2.s;\r\n\r\n                }\r\n\r\n                return t1.m < t2.m;\r\n\r\n            }\r\n\r\n            return t1.h < t2.h;\r\n\r\n        }\r\n\r\n        \r\n\r\n        friend ostream& operator << ( ostream &os, const dtime &t ){\r\n\r\n            os << t.h << \" \" << t.m << \" \" << t.s << endl;\r\n\r\n            return os;\r\n\r\n        }\r\n\r\n\r\n\r\n        friend string to_string( const dtime &t ){\r\n\r\n            return to_string( t.h ) + \":\" + to_string( t.m ) + \":\" + to_string( t.s );  \r\n\r\n        }\r\n\r\n    };\r\n\r\n\r\n\r\n    dtime get_current_time() {\r\n\r\n        return dtime();\r\n\r\n    }\r\n\r\n\r\n\r\n} using namespace utils;\r\n\r\n\r\n\r\ntemplate<typename T> class nparray {\r\n\r\n\r\n\r\nprivate:\r\n\r\n    T * _data = nullptr, * _max = nullptr, * _min = nullptr, * _sum = nullptr;\r\n\r\n    size_t _size;\r\n\r\n\r\n\r\npublic:\r\n\r\n    nparray(){}\r\n\r\n    nparray( size_t size ) { __init( size ); }\r\n\r\n\r\n\r\n    void __init( size_t size ){ _size = size; _data = new T[size]; fill( 0 ); }\r\n\r\n    \r\n\r\n    T sum() { return std::accumulate( _data, _data + _size, 0 ); }\r\n\r\n    T sum( size_t stop ) { return sum( 0, stop ); }\r\n\r\n    T sum( size_t start, size_t stop ){ if( _sum == nullptr ) __sumrecalc(); T sum_ = _sum[stop]; if( start ) sum_ -= _sum[start - 1]; return sum_; }\r\n\r\n    T sum( size_t start, size_t stop, size_t step ) { T sum_ = 0; for( size_t i = start; i < stop; i += step ) { sum_ += _data[i]; } return sum_; }\r\n\r\n    \r\n\r\n    T max(){ return std::max_element( _data, _data + this -> _size ); }\r\n\r\n    T max( size_t index ){ assert( index < _size ); if( _max == nullptr ) __maxrecalc(); return _max[index]; }\r\n\r\n\r\n\r\n    T min(){ return std::min_element( _data, _data + _size ); }\r\n\r\n    T min( size_t index ){ assert( index < _size ); if( _min == nullptr ) __minrecalc(); return _min[index]; }\r\n\r\n\r\n\r\n    T* begin() { return _data; }\r\n\r\n    T* end() { return _data + _size; }\r\n\r\n\r\n\r\n    T* cbegin() { return _data + _size - 1; }\r\n\r\n    T* cend() { return _data - 1; }\r\n\r\n\r\n\r\n    void fill( int value ){ std::fill( _data, _data + _size, value ); }\r\n\r\n    void reverse( ){ std::reverse( _data, _data + _size ); if( _sum != nullptr ) std::reverse( _sum, _sum + _size ); if( _max != nullptr ) std::reverse( _max, _max + _size ); if( _min != nullptr ) std::reverse( _min, _min + _size ); }\r\n\r\n    void sort( ){ std::sort( _data, _data + _size ); if( _sum != nullptr ) __sumrecalc(); if( _max != nullptr ) __maxrecalc(); if( _min != nullptr ) __minrecalc(); }\r\n\r\n    void shift( int count ) { count %= ( int32_t )_size; T *temp = new T[_size]; int j = ( count < 0 ? _size + count: count ); for( size_t i = 0; i < _size; i++, j++ ){ if( j == _size ) j = 0; temp[j] = _data[i]; } for( size_t i = 0; i < _size; i++ ){ _data[i] = temp[i]; } delete temp; }\r\n\r\n    void random_shuffle( ){ std::random_shuffle( _data, _data + _size );  }\r\n\r\n    bool is_sorted( ){ for( int i = 1; i < _size; i++ ){ if( _data[i - 1] > _data[i + 1] ){ return false; } } return true; }\r\n\r\n    void resize( size_t size ) { __clear(); __init( size ); }\r\n\r\n\r\n\r\n    void __clear() { _size = 0; delete _data; delete _max; delete _min; delete _sum; }\r\n\r\n    void __sumrecalc(){ _sum = new T[_size]; _sum[0] = _data[0]; for( int i = 1; i < _size; i++ ){ _sum[i] = _sum[i - 1] + _data[i]; } }\r\n\r\n    void __maxrecalc(){ _max = new T[_size]; _max[0] = _data[0]; for( int i = 1; i < _size; i++ ){ _max[i] = ( _data[i] > _max[i - 1] ? _data[i] : _max[i - 1]); } }\r\n\r\n    void __minrecalc(){ _min = new T[_size]; _min[0] = _data[0]; for( int i = 1; i < _size; i++ ){ _min[i] = ( _data[i] < _min[i - 1] ? _data[i] : _min[i - 1]); } }\r\n\r\n\r\n\r\n    T& operator [] ( int index ){ if( index < 0 ){ assert( -index <= _size ); return _data[_size + index]; } else { assert( index < _size ); return _data[index]; } }\r\n\r\n    size_t size() { return _size; }\r\n\r\n    bool empty(){ return ( _size == 0 ); }\r\n\r\n\r\n\r\n    friend ostream& operator << ( ostream &os, nparray<T> &array ) { for( size_t i = 0; i < array.size(); i++ ) { if( i ) os << \" \"; os << array[i]; } return os; }\r\n\r\n    friend istream& operator >> ( istream &is, nparray<T> &array ) { for( size_t i = 0; i < array.size(); i++ ) { is >> array[i]; } return is; }\r\n\r\n    \r\n\r\n    friend string to_string( nparray<T> &array ){ string s = \"{ \"; for( size_t i = 0; i < array.size(); i++ ) { if( i ) s += \", \"; s += to_string( array[i] ); } s += \"}\"; return s; }\r\n\r\n    ~nparray() { __clear(); }\r\n\r\n  \r\n\r\n};\r\n\r\n\r\n\r\n\/*\r\n\r\n    main\r\n\r\n*\/\r\n\r\n\r\n\r\n#ifdef LOCAL_JUDGE\r\n\r\n#define print( ... ) cerr << \"[\" << #__VA_ARGS__ << \"]: \"; io::print( __VA_ARGS__ );\r\n\r\n#else\r\n\r\n#define print( ... )\r\n\r\n#endif\r\n\r\n\r\n\r\nconst int MOD = 1'000'000'007; \/\/ 998'244'353\r\n\r\nconst double EPS = 1e-9;\r\n\r\nconst double PI = acos( -1. );\r\n\r\nlong long LLINF = 18_E + 10;\r\n\r\nint INF = 9_E + 10;\r\n\r\n\r\n\r\nconst int MAXN = 6_E + 6;\r\n\r\nconst int N = 5 * 3_E + 5;\r\n\r\n\r\n\r\nstruct box {\r\n\r\n    int a, b, c;\r\n\r\n};\r\n\r\n\r\n\r\nint get( const box &b, int i ){\r\n\r\n    if( i == 0 ){\r\n\r\n        return b.a;\r\n\r\n    } else if( i == 1 ){\r\n\r\n        return b.b;\r\n\r\n    } else {\r\n\r\n        return b.c;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nint calc( const vector<box> &boxes, int i, int ci, int j, int cj, int k, int ck ){\r\n\r\n    int cnt[3] = { 0 };\r\n\r\n    int s[3] = { 0 };\r\n\r\n    cnt[ci]++;\r\n\r\n    cnt[cj]++;\r\n\r\n    cnt[ck]++;\r\n\r\n    int all = 0;\r\n\r\n    int sum = get( boxes[i], ci ) + get( boxes[j], cj ) + get( boxes[k], ck );\r\n\r\n    for( int l = 0; l < 3; l++ ){\r\n\r\n        if( l != ci ){\r\n\r\n            s[l] += get( boxes[i], l );\r\n\r\n        }\r\n\r\n        if( l != cj ){\r\n\r\n            s[l] += get( boxes[j], l );\r\n\r\n        }\r\n\r\n        if( l != ck ){\r\n\r\n            s[l] += get( boxes[k], l );\r\n\r\n        }\r\n\r\n    }\r\n\r\n    for( int l = 0; l < boxes.size(); l++ ){\r\n\r\n        all += boxes[l].a + boxes[l].b + boxes[l].c;\r\n\r\n        if( l == i || l == j || l == k ){\r\n\r\n            continue;\r\n\r\n        }\r\n\r\n        int max_i = 0;\r\n\r\n        if( boxes[l].b > boxes[l].a ){\r\n\r\n            max_i = 1;\r\n\r\n        }\r\n\r\n        if( boxes[l].c > boxes[l].b && boxes[l].c > boxes[l].a ){\r\n\r\n            max_i = 2;\r\n\r\n        }\r\n\r\n        cnt[max_i]++;\r\n\r\n        sum += get( boxes[l], max_i );\r\n\r\n        for( int a = 0; a < 3; a++ ){\r\n\r\n            if( a != max_i ){\r\n\r\n                s[a] += get( boxes[l], a );\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    if( ( cnt[0] > 0 || s[0] == 0 ) && ( cnt[1] > 0 || s[1] == 0 ) && ( cnt[2] > 0 || s[2] == 0 ) ){\r\n\r\n        return all - sum;\r\n\r\n    } else {\r\n\r\n        return INF;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nint calc2( const vector<box> &boxes, int i, int ci, int j, int cj ){\r\n\r\n    int cnt[3] = { 0 };\r\n\r\n    int s[3] = { 0 };\r\n\r\n    cnt[ci]++;\r\n\r\n    cnt[cj]++;\r\n\r\n    int all = 0;\r\n\r\n    int sum = get( boxes[i], ci ) + get( boxes[j], cj );\r\n\r\n    for( int l = 0; l < 3; l++ ){\r\n\r\n        if( l != ci ){\r\n\r\n            s[l] += get( boxes[i], l );\r\n\r\n        }\r\n\r\n        if( l != cj ){\r\n\r\n            s[l] += get( boxes[j], l );\r\n\r\n        }\r\n\r\n    }\r\n\r\n    for( int l = 0; l < boxes.size(); l++ ){\r\n\r\n        all += boxes[l].a + boxes[l].b + boxes[l].c;\r\n\r\n        if( l == i || l == j ){\r\n\r\n            continue;\r\n\r\n        }\r\n\r\n        int max_i = 0;\r\n\r\n        if( boxes[l].b > boxes[l].a ){\r\n\r\n            max_i = 1;\r\n\r\n        }\r\n\r\n        if( boxes[l].c > boxes[l].b && boxes[l].c > boxes[l].a ){\r\n\r\n            max_i = 2;\r\n\r\n        }\r\n\r\n        cnt[max_i]++;\r\n\r\n        sum += get( boxes[l], max_i );\r\n\r\n        for( int a = 0; a < 3; a++ ){\r\n\r\n            if( a != max_i ){\r\n\r\n                s[a] += get( boxes[l], a );\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    if( ( cnt[0] > 0 || s[0] == 0 ) && ( cnt[1] > 0 || s[1] == 0 ) && ( cnt[2] > 0 || s[2] == 0 ) ){\r\n\r\n        return all - sum;\r\n\r\n    } else {\r\n\r\n        return INF;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nvoid solution( istream &cin, ostream &cout, const int &test_case )\r\n\r\n{\r\n\r\n    int n;\r\n\r\n    cin >> n;\r\n\r\n    vector<box> a( n );\r\n\r\n    for( int i = 0; i < n; i++ ){\r\n\r\n        cin >> a[i].a >> a[i].b >> a[i].c;\r\n\r\n    }\r\n\r\n    int ans = INF;\r\n\r\n    for( int i = 0; i < n; i++ ){\r\n\r\n        for( int j = i + 1; j < n; j++ ){\r\n\r\n            for( int k = j + 1; k < n; k++ ){\r\n\r\n                for( int c1 = 0; c1 < 3; c1++ ){\r\n\r\n                    for( int c2 = 0; c2 < 3; c2++ ){\r\n\r\n                        for( int c3 = 0; c3 < 3; c3++ ){\r\n\r\n                            if( c1 == c2 || c1 == c3 || c2 == c3 ){\r\n\r\n                                continue;\r\n\r\n                            }\r\n\r\n                            ans = min( ans, calc( a, i, c1, j, c2, k, c3 ) );\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    for( int i = 0; i < n; i++ ){\r\n\r\n        for( int j = i + 1; j < n; j++ ){\r\n\r\n            for( int c1 = 0; c1 < 3; c1++ ){\r\n\r\n                for( int c2 = 0; c2 < 3; c2++ ){\r\n\r\n                    ans = min( ans, calc2( a, i, c1, j, c2 ) );\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    if( n == 1 ){\r\n\r\n        int cnt0 = ( a[0].a == 0 ) + ( a[0].b == 0 ) + ( a[0].c == 0 );\r\n\r\n        if( cnt0 >= 2 ){\r\n\r\n            cout << 0 << endl;\r\n\r\n        } else {\r\n\r\n            cout << -1 << endl;\r\n\r\n        }\r\n\r\n        return;\r\n\r\n    }\r\n\r\n    if( ans == INF ){\r\n\r\n        ans = -1;        \r\n\r\n    }\r\n\r\n    cout << ans << endl;\r\n\r\n}\r\n\r\n\r\n\r\nint32_t main()\r\n\r\n{\r\n\r\n\r\n\r\n    srand( time( 0 ) );\r\n\r\n\r\n\r\n    ios_base::sync_with_stdio( false ); cin.tie( nullptr ); cout.tie( nullptr );\r\n\r\n    \r\n\r\n    std::istream& in( std::cin ); \r\n\r\n    std::ostream& out( std::cout );\r\n\r\n    \r\n\r\n    int32_t queries = 1;\r\n\r\n    \/\/ cin >> queries;\r\n\r\n\r\n\r\n    for( int32_t test_case: range( 1, queries + 1 ) ){\r\n\r\n        solution( cin, cout, test_case );\r\n\r\n    }\r\n\r\n \r\n\r\n    return EXIT_SUCCESS;\r\n\r\n \r\n\r\n}","lang":4}