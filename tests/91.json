{"code":"#include <bits\/stdc++.h>\r\n\r\nusing namespace std ;\r\n\r\n#define ft first\r\n\r\n#define sd second\r\n\r\n#define pb push_back\r\n\r\n#define all(x) x.begin(),x.end()\r\n\r\n#define ll long long int\r\n\r\n#define vi vector<int>\r\n\r\n#define vii vector<pair<int,int> >\r\n\r\n#define pii pair<int,int>\r\n\r\n#define plii pair<pair<ll, int>, int>\r\n\r\n#define piii pair<pii, int>\r\n\r\n#define viii vector<pair<pii, int> >\r\n\r\n#define vl vector<ll>\r\n\r\n#define vll vector<pair<ll,ll> >\r\n\r\n#define pll pair<ll,ll>\r\n\r\n#define pli pair<ll,int>\r\n\r\n#define mp make_pair\r\n\r\n#define ms(x, v) memset(x, v, sizeof x)\r\n\r\n#define sc1(x) scanf(\"%d\",&x)\r\n\r\n#define sc2(x,y) scanf(\"%d%d\",&x,&y)\r\n\r\n#define sc3(x,y,z) scanf(\"%d%d%d\",&x,&y,&z)\r\n\r\n#define scll1(x) scanf(\"%lld\",&x)\r\n\r\n#define scll2(x,y) scanf(\"%lld%lld\",&x,&y)\r\n\r\n#define scll3(x,y,z) scanf(\"%lld%lld%lld\",&x,&y,&z)\r\n\r\n#define pr1(x) printf(\"%d\\n\",x)\r\n\r\n#define pr2(x,y) printf(\"%d %d\\n\",x,y)\r\n\r\n#define pr3(x,y,z) printf(\"%d %d %d\\n\",x,y,z)\r\n\r\n#define prll1(x) printf(\"%lld\\n\",x)\r\n\r\n#define prll2(x,y) printf(\"%lld %lld\\n\",x,y)\r\n\r\n#define prll3(x,y,z) printf(\"%lld %lld %lld\\n\",x,y,z)\r\n\r\n#define pr_vec(v) for(int i=0;i<v.size();i++) cout << v[i] << \" \" ;\r\n\r\n#define f_in(st) freopen(st,\"r\",stdin)\r\n\r\n#define f_out(st) freopen(st,\"w\",stdout)\r\n\r\n#define fr(i, a, b) for(i=a; i<=b; i++)\r\n\r\n#define fb(i, a, b) for(i=a; i>=b; i--)\r\n\r\n#define ASST(x, l, r) assert( x <= r && x >= l )\r\n\r\n#include <ext\/pb_ds\/assoc_container.hpp>\r\n\r\n#include <ext\/pb_ds\/tree_policy.hpp>\r\n\r\nconst int mod = 1e9 + 7;\r\n\r\nint ADD(int a, int b, int m = mod) {\r\n\r\n    int s = a;\r\n\r\n    s += b;\r\n\r\n    if( s >= m )\r\n\r\n      s -= m;\r\n\r\n    return s;\r\n\r\n}\r\n\r\nint MUL(int a, int b, int m = mod) {\r\n\r\n    return (1LL * a * b % m);\r\n\r\n}\r\n\r\nint power(int a, int b, int m = mod) {\r\n\r\n    int res = 1;\r\n\r\n    while( b ) {\r\n\r\n        if( b & 1 ) {\r\n\r\n            res = 1LL * res * a % m;\r\n\r\n        }\r\n\r\n        a = 1LL * a * a % m;\r\n\r\n        b \/= 2;\r\n\r\n    }\r\n\r\n    return res;\r\n\r\n}\r\n\r\nll nC2(ll x) {\r\n\r\n    return ( x * ( x - 1 ) \/ 2 );\r\n\r\n}\r\n\r\nconst int maxn = 1e6 + 5;\r\n\r\nchar s1[ maxn ], s2[ maxn ], s[ maxn ];\r\n\r\nint p1[ maxn ], p2[ maxn ];\r\n\r\nint n, m, len, num, suff, fd[ maxn ], bd[ maxn ]; \/\/ node 1 - root with len -1, node 2 - root with len 0 ,  max suffix palindrome\r\n\r\nchar txt[ maxn ];\r\n\r\nint iSA[maxn], SA[maxn]; \/\/output\r\n\r\nint cnt[maxn], next_gen[maxn], lcp[maxn], LCP[maxn][22], sa1[ maxn ], sa2[ maxn ]; \/\/internal\r\n\r\nbool bh[maxn], b2h[maxn];\r\n\r\nvoid reset( int len ) {\r\n\r\n    int i; fr(i, 0, len) {\r\n\r\n        iSA[i] = 0;\r\n\r\n        SA[i] = 0;\r\n\r\n        cnt[i] = 0;\r\n\r\n        next_gen[i] = 0;\r\n\r\n        lcp[i] = 0;\r\n\r\n        bh[i] = 0;\r\n\r\n        b2h[i] = 0;\r\n\r\n        int j;\r\n\r\n        fr(j, 0, 20)\r\n\r\n            LCP[i][j] = 0;\r\n\r\n    }\r\n\r\n}\r\n\r\nbool smaller_first_char(int a, int b){\r\n\r\n    return txt[a] < txt[b];\r\n\r\n}\r\n\r\nvoid SuffixSort(int n) {\r\n\r\n    for (int i=0; i<n; ++i){\r\n\r\n        SA[i] = i;\r\n\r\n    }\r\n\r\n    sort(SA, SA + n, smaller_first_char);\r\n\r\n    for (int i=0; i<n; ++i){\r\n\r\n        bh[i] = i == 0 || txt[SA[i]] != txt[SA[i-1]];\r\n\r\n        b2h[i] = false;\r\n\r\n    }\r\n\r\n    for (int h = 1; h < n; h <<= 1){\r\n\r\n        int buckets = 0;\r\n\r\n        for (int i=0, j; i < n; i = j){\r\n\r\n            j = i + 1;\r\n\r\n            while (j < n && !bh[j]) j++;\r\n\r\n            next_gen[i] = j;\r\n\r\n            buckets++;\r\n\r\n        }\r\n\r\n        if (buckets == n) break;\r\n\r\n        for (int i = 0; i < n; i = next_gen[i]){\r\n\r\n            cnt[i] = 0;\r\n\r\n            for (int j = i; j < next_gen[i]; ++j){\r\n\r\n                iSA[SA[j]] = i;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        cnt[iSA[n - h]]++;\r\n\r\n        b2h[iSA[n - h]] = true;\r\n\r\n        for (int i = 0; i < n; i = next_gen[i]){\r\n\r\n            for (int j = i; j < next_gen[i]; ++j){\r\n\r\n                int s = SA[j] - h;\r\n\r\n                if (s >= 0){\r\n\r\n                int head = iSA[s];\r\n\r\n                iSA[s] = head + cnt[head]++;\r\n\r\n                b2h[iSA[s]] = true;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            for (int j = i; j < next_gen[i]; ++j){\r\n\r\n                int s = SA[j] - h;\r\n\r\n                if (s >= 0 && b2h[iSA[s]]){\r\n\r\n                    for (int k = iSA[s]+1; !bh[k] && b2h[k]; k++) b2h[k] = false;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n      for (int i=0; i<n; ++i){\r\n\r\n            SA[iSA[i]] = i;\r\n\r\n            bh[i] |= b2h[i];\r\n\r\n        }\r\n\r\n    }\r\n\r\n    for (int i=0; i<n; ++i){\r\n\r\n        iSA[SA[i]] = i;\r\n\r\n    }\r\n\r\n}\r\n\r\nvoid InitLCP(int n) {\r\n\r\n    for (int i=0; i<n; ++i) \r\n\r\n        iSA[SA[i]] = i;\r\n\r\n    lcp[0] = 0;\r\n\r\n    for (int i=0, h=0; i<n; ++i)\r\n\r\n    {\r\n\r\n        if (iSA[i] > 0)\r\n\r\n        {\r\n\r\n            int j = SA[iSA[i]-1];\r\n\r\n            while (i + h < n && j + h < n && txt[i+h] == txt[j+h]) \r\n\r\n                h++;\r\n\r\n            lcp[iSA[i]] = h;\r\n\r\n            if (h > 0) \r\n\r\n                h--;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nvoid ConstructLCP() {\r\n\r\n    InitLCP( len );\r\n\r\n    for(int i = 0;i<len;++i)\r\n\r\n        LCP[i][0] = lcp[i];\r\n\r\n    for(int j = 1;(1<<j)<=len;++j){\r\n\r\n        for(int i = 0;i+(1<<j)-1<len;++i){\r\n\r\n            if(LCP[i][j-1]<=LCP[i+ ( 1<<(j-1) )][j-1])\r\n\r\n                LCP[i][j] = LCP[i][j-1];\r\n\r\n            else\r\n\r\n                LCP[i][j] = LCP[i+(1<<(j-1))][j-1];\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nint GetLCP(int x, int y) {\r\n\r\n    if(x == y) return len-SA[x];\r\n\r\n    if(x > y) swap(x,y);\r\n\r\n    int log = 0;\r\n\r\n    while((1<<log)<=(y-x)) ++log;\r\n\r\n    --log;\r\n\r\n    return min(LCP[x+1][log],LCP[y-(1<<log)+1][log]);\r\n\r\n}\r\n\r\nstruct node {\r\n\r\n    int next[26];\r\n\r\n    int len;\r\n\r\n    int sufflink;\r\n\r\n};\r\n\r\nnode tree[maxn];\r\n\r\nbool addLetter(int pos) {\r\n\r\n    int cur = suff, curlen = 0;\r\n\r\n    int let = s[pos] - 'a';\r\n\r\n    while (true) {\r\n\r\n        curlen = tree[cur].len;\r\n\r\n        if (pos - 1 - curlen >= 0 && s[pos - 1 - curlen] == s[pos])      \r\n\r\n            break;  \r\n\r\n        cur = tree[cur].sufflink;\r\n\r\n    }    \r\n\r\n    if (tree[cur].next[let]) {  \r\n\r\n        suff = tree[cur].next[let];\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n    num++;\r\n\r\n    suff = num;\r\n\r\n    tree[num].len = tree[cur].len + 2;\r\n\r\n    tree[cur].next[let] = num;\r\n\r\n    if (tree[num].len == 1) {\r\n\r\n        tree[num].sufflink = 2;\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    while (true) {\r\n\r\n        cur = tree[cur].sufflink;\r\n\r\n        curlen = tree[cur].len;\r\n\r\n        if (pos - 1 - curlen >= 0 && s[pos - 1 - curlen] == s[pos]) {\r\n\r\n            tree[num].sufflink = tree[cur].next[let];\r\n\r\n            break;\r\n\r\n        }      \r\n\r\n    }\r\n\r\n    return true;\r\n\r\n}\r\n\r\nvoid initTree() {\r\n\r\n    num = 2; suff = 2;\r\n\r\n    tree[1].len = -1; tree[1].sufflink = 1;\r\n\r\n    tree[2].len = 0; tree[2].sufflink = 1;\r\n\r\n}\r\n\r\nvoid solve() {\r\n\r\n    scanf(\"%s\", s1);\r\n\r\n    scanf(\"%s\", s2);\r\n\r\n    n = strlen( s1 );\r\n\r\n    m = strlen( s2 );\r\n\r\n    int i;\r\n\r\n    len = n;\r\n\r\n    reset( len );\r\n\r\n    fr(i, 0, n-1) txt[i] = s1[i];\r\n\r\n    SuffixSort( len );\r\n\r\n    fr(i, 0, n-1) sa1[i] = iSA[i];\r\n\r\n    len = m;\r\n\r\n    reset( len );\r\n\r\n    fr(i, 0, m-1) txt[i] = s2[m-1-i];\r\n\r\n    SuffixSort( len );\r\n\r\n    fr(i, 0, m-1) sa2[m-1-i] = iSA[i];\r\n\r\n    fr(i, 0, n-1) \r\n\r\n        s[i] = s1[n-1-i];\r\n\r\n    initTree();\r\n\r\n    fr(i, 0, n-1) {\r\n\r\n        addLetter( i );\r\n\r\n        p1[n-1-i] = tree[suff].len;\r\n\r\n    }\r\n\r\n    p1[ n ] = 0;\r\n\r\n    fr(i, 1, num) {\r\n\r\n        tree[i].len = 0;\r\n\r\n        tree[i].sufflink = 0;\r\n\r\n        ms(tree[i].next, 0);\r\n\r\n    }\r\n\r\n    fr(i, 0, m-1) \r\n\r\n        s[i] = s2[i];\r\n\r\n    initTree();\r\n\r\n    fr(i, 0, m-1) {\r\n\r\n        addLetter( i );\r\n\r\n        p2[i] = tree[suff].len;\r\n\r\n    }\r\n\r\n    fr(i, 1, num) {\r\n\r\n        tree[i].len = 0;\r\n\r\n        tree[i].sufflink = 0;\r\n\r\n        ms(tree[i].next, 0);\r\n\r\n    }\r\n\r\n    len = n + m + 1;\r\n\r\n    reset( len );\r\n\r\n    fr(i, 0, n-1) txt[i] = s1[n-1-i];\r\n\r\n    txt[n] = '$';\r\n\r\n    fr(i, n+1, n+m) txt[i] = s2[i-n-1];\r\n\r\n    SuffixSort( len );\r\n\r\n    ConstructLCP();\r\n\r\n    int pos1, pos2;\r\n\r\n    pos1 = pos2 = -1;\r\n\r\n    fr(i, 0, len - 1) {\r\n\r\n        if( SA[i] > n ) {\r\n\r\n            bd[SA[i]] = pos1;\r\n\r\n            pos2 = SA[i];\r\n\r\n        } else if( SA[i] < n ){\r\n\r\n            bd[SA[i]] = pos2;\r\n\r\n            pos1 = SA[i];\r\n\r\n        }\r\n\r\n    }\r\n\r\n    pos1 = pos2 = -1;\r\n\r\n    fb(i, len - 1, 0) {\r\n\r\n        if( SA[i] > n ) {\r\n\r\n            fd[SA[i]] = pos1;\r\n\r\n            pos2 = SA[i];\r\n\r\n        } else if( SA[i] < n ) {\r\n\r\n            fd[SA[i]] = pos2;\r\n\r\n            pos1 = SA[i];\r\n\r\n        }\r\n\r\n    }\r\n  int l, r, currlen = 0;\r\n\r\n    l = r = -1;\r\n\r\n    currlen = 0;\r\n\r\n    fr(i, 0, n-1) {\r\n\r\n        int temp = 0;\r\n\r\n        if( fd[n-1-i] != -1 ) temp = max( temp, GetLCP(iSA[n-1-i], iSA[fd[n-1-i]]) );\r\n\r\n        if( bd[n-1-i] != -1 ) temp = max( temp, GetLCP(iSA[n-1-i], iSA[bd[n-1-i]]) );\r\n\r\n        if( temp && currlen < temp * 2 + p1[i+1] ) {\r\n\r\n            l = i - temp + 1;\r\n\r\n            r = i + p1[i+1];\r\n\r\n            currlen = temp * 2 + p1[i+1];\r\n\r\n        } else if( temp && currlen == temp * 2 + p1[i+1] ) {\r\n\r\n            if(sa1[i-temp+1] < sa1[l]) {\r\n\r\n                l = i - temp + 1;\r\n\r\n                r = i + p1[i+1];\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    if( currlen == 0 ) {\r\n\r\n        cout << -1 << \"\\n\";\r\n\r\n        return;\r\n\r\n    }\r\n\r\n    string f1, f2;\r\n\r\n    f1.resize(currlen);\r\n\r\n    int j;\r\n\r\n    i = 0; j = currlen  - 1;\r\n\r\n    while( l <= r ) {\r\n\r\n        f1[i] = f1[j] = s1[l];\r\n\r\n        l ++;\r\n\r\n        i ++; j --;\r\n\r\n    }\r\n\r\n    l = r = -1;\r\n\r\n    currlen = 0;\r\n\r\n    fr(i, 0, m-1) {\r\n\r\n        int temp = 0, p = 0;\r\n\r\n        p = (i ? p2[i-1]: 0);\r\n\r\n        if( fd[n+i+1] != -1 ) temp = max( temp, GetLCP(iSA[n+i+1], iSA[fd[n+i+1]]) );\r\n\r\n        if( bd[n+i+1] != -1 ) temp = max( temp, GetLCP(iSA[n+i+1], iSA[bd[n+i+1]]) );\r\n\r\n        if( temp && currlen < temp * 2 + p ) {\r\n\r\n            r = i+temp-1;\r\n\r\n            l = i-p;\r\n\r\n            currlen = temp * 2 + p;\r\n\r\n        } else if( temp && currlen == temp * 2 + p ) {\r\n\r\n            if(sa2[i+temp-1] < sa2[r]) {\r\n\r\n                r = i+temp-1;\r\n\r\n                l = i-p;\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    f2.resize( currlen );\r\n\r\n    i = 0; j = currlen - 1;\r\n\r\n    while( l <= r ) {\r\n\r\n        f2[i] = f2[j] = s2[r];\r\n\r\n        r --; i ++; j --;\r\n\r\n    }\r\n\r\n    if( f1.length() != f2.length() ) {\r\n\r\n        if( f1.length() < f2.length() ) cout << f2 << \"\\n\";\r\n\r\n        else cout << f1 << \"\\n\";\r\n\r\n    } else {\r\n\r\n        if( f1 < f2 ) cout << f1 << \"\\n\";\r\n\r\n        else cout << f2 << \"\\n\";\r\n\r\n    }\r\n\r\n}\r\n\r\nint main() {\r\n\r\n    int t; sc1( t );\r\n\r\n    while( t-- ) solve();\r\n\r\n}","lang":4}